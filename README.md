# 自用魔改版，出问题概不负责

根据项目需求魔改了一部分代码，支持直接根据 sln 生成 lua 代码，但生成的代码还有一些小问题，路子比较野，反正是临时工具，用一把就完。

## 原理

compile files --> c# ast --> lua ast --> lua code

具体可阅读原始库中的文档，里面都有解释

## 如何使用

1. 需要 vs2022

2. 因为时间有限，对 c#环境也不熟悉，所以直接把 roslyn 库源码下了下来，将此工程中的 CSharp.lua 以及 CSharp.lua.Launcher 添加到 roslyn 进行 build，然后运行 CSharp.lua.Launcher，命令行参数

```
-s source_path -d target_path -mssln sln_path
```

3. LuaIdentifierNameSyntax.cs 以及 System.xml 看需求自己改名字

## 感想

所有热更方案的前提(不管是 unity 还是虚幻)，上来第一件事先得把模块划分清楚，不热更的，需要热更的，模块和模块间的关系越简单越好，互相引用越少越好。像我现在接手的这个项目，模块间耦合关系太重，拆干净实在是费劲，在这个前提下，什么热更方案都费劲。

在上面前提下如果把模块拆的足够干净、独立，那么就可以考虑各种热更方案，基本思路就是把需要热更的代码和不需要的进行分割，通过桥接系统也好，delegate 也好进行互通。

此时世面上最常用的选择就是 lua，用 lua 代码实现需要热更的部分，然后运行时解释执行就完了。但众所周知，lua 这东西没类型，虽说简单，但量大到一定份上管理成本超级高，一般大规模写 lua 要限制很多东西，比如最好别改\_G（全局变量要稳定可控），metatable 不能随便用（要不然查起来更费劲），命名上最好有 type 前缀（方便查看或者引入 emmylua 靠注释解决 type），引擎资源引用问题（lua 引用没释放导致引擎资源也被 hold 了），再加上调试问题等，所以拿捏不好容易写飞。

像 ILRuntime 就是个基于 c#的解决方案，写 c#代码，然后解释执行，类似 mono 的解释器，写的时候很爽，但之前听说运行时有不少坑，现在应该好了不少，但毕竟没用过，也发表不了什么见解，了解下来大厂用这个的项目比较少。

开发时如果能写 c#那最爽，运行时用 lua 最稳妥（毕竟大厂都在用），所以现在这个 CSharp.lua 的必要性就有了，既可以满足开发期的需求，又可以让运行时走 lua。但是看似很美好的东西，其实这里也有一些问题：第一对 c#的写法有一定要求，虽说绝大部分语法都支持，但至少在我这个项目里，转出来的代码还会有一些 api 不对，或者类型不对的情况，所以要用的话尽量别上太复杂的类型（这点 ILRuntime 也一样）；第二就是如果 lua 产生了性能或者内存问题，怎么去优化，因为是靠 c#转换的，如果是逻辑费到还好，优化优化逻辑就完了， 但如果是写法问题，那就只能改 lua 代码，但直接改 lua 代码又和这个转换思想违背（这条其实最致命）。

最后总结下来就是，如果最开始就打算上热更，那上传统方案比较稳妥（lua 最稳妥，ILRuntime 得研究研究），如果是前期 c#，后期想改成带热更的，如果是大项目，那基本只能上 hotfix，小项目可以用用这个 CSharp.lua，但是也得先把模块划分清楚，把耦合关系摘干净点，要不然转出来也是个噩梦。

# CSharp.lua

The C# to Lua compiler.

## Introduction

CSharp.lua is a C# to Lua compiler. Write C# then run on lua VM.

- Build on [Microsoft Roslyn](https://github.com/dotnet/roslyn). Support for C# 9.0.

- Highly readable code generation. C# AST ---> Lua AST ---> Lua Code.

- Allowing almost all of the C# language features.

- Provides [CoreSystem.lua](https://github.com/yanghuan/CSharp.lua/tree/master/CSharp.lua/CoreSystem.Lua/CoreSystem) library, can run away of CLR.

- Self-Compiling, run "./test/self-compiling/self.bat".

- Self-Compiling (linux), run "./make" (if no errors, will prompt for fibbonacci 'N' value and generate fib sequence in lua)

- Used by .NET Core, Ability to across platforms.

## Sample

C# code

```csharp
using System;

namespace HelloLua {
  public static class Program {
    public static void Main() {
      Console.WriteLine("hello lua!");
    }
  }
}
```

To Lua

```lua
-- Generated by CSharp.lua Compiler
local System = System
System.namespace("HelloLua", function (namespace)
  namespace.class("Program", function (namespace)
    local Main
    Main = function ()
      System.Console.WriteLine("hello lua!")
    end
    return {
      Main = Main
    }
  end)
end)
```

## Try Live

https://yanghuan.github.io/external/bridgelua-editor/index.html

## How to Use

### Command Line Parameters

```cmd
D:\>dotnet CSharp.Lua.Launcher.dll -h
Usage: CSharp.lua [-s srcfolder] [-d dstfolder]
Arguments
-s              : can be a directory where all cs files will be compiled, or a list of files, using ';' or ',' to separate
-d              : destination directory, will put the out lua files

Options
-h              : show the help message and exit
-l              : libraries referenced, use ';' to separate
                  if the librarie is a module, whitch is compield by CSharp.lua with -module arguemnt, the last character needs to be '!' in order to mark

-m              : meta files, like System.xml, use ';' to separate
-csc            : csc.exe command argumnets, use ' ' or '\t' to separate

-c              : support classic lua version(5.1), default support 5.3
-a              : attributes need to export, use ';' to separate, if ""-a"" only, all attributes whill be exported
-e              : enums need to export, use ';' to separate, if ""-e"" only, all enums will be exported
-ei             : enums is represented by a variable reference rather than a constant value, need to be used with -e
-p              : do not use debug.setmetatable, in some Addon/Plugin environment debug object cannot be used
-metadata       : export all metadata, use @CSharpLua.Metadata annotations for precise control
-module         : the currently compiled assembly needs to be referenced, it's useful for multiple module compiled
-inline-property: inline some single-line properties
-include        : the root directory of the CoreSystem library, adds all the dependencies to a single file named out.lua
-noconcurrent   : close concurrent compile
```

Make sure that .NET 6.0 is installed.
https://dotnet.microsoft.com/download/dotnet/6.0

### Download

https://github.com/yanghuan/CSharp.lua/releases

## CoreSystem.lua

[CoreSystem.lua library](https://github.com/yanghuan/CSharp.lua/tree/master/CSharp.lua/CoreSystem.Lua/CoreSystem) that implements most of the [.NET Framework core classes](http://referencesource.microsoft.com/), including support for basic type, delegate, generic collection classes & linq. The Converted lua code, need to reference it

## Example

- [fibonacci](https://github.com/yanghuan/CSharp.lua/tree/master/test/fibonacci), a console program code, print Fibonacci number.

## Documentation

https://github.com/yanghuan/CSharp.lua/wiki

## _License_

[Apache 2.0 license](https://raw.githubusercontent.com/yanghuan/CSharp.lua/master/LICENSE).

## _Acknowledgements_

- [Bridge.NET](http://bridge.net/)
- [WootzJs](https://github.com/kswoll/WootzJs)
- [.NET referencesource](http://referencesource.microsoft.com/)
- [Resharper](https://www.jetbrains.com/resharper/)

## Communication

- [Issues](https://github.com/yanghuan/CSharp.lua/issues)
- Mail：sy.yanghuan@gmail.com
- QQ Group: 715350749 (Chinese Only)
